// Just a bunch of function ideas, not yet tested.

void t2::exit_search(Robots robot, Mazes this_maze)
{
	step_counter = 0;
	
	/* coordinated of the robot, are directly accessible since they're
		stored in Robots (or t2) */
	int v = robot.v;
	int h = robot.h;
	
	while (!(v == this_maze.mazexit[0]) && h == this_maze.mazeexit[1])
	
	if (this_maze.is_wall(v, h, robot.direction))
	{
		turn_left(robot);
		exit_search(robot, v, h, this_maze);
	}
	else
	{
		step_forward(robot);
		step_counter++;
	}
}

/* There will be a problem because the mymaze in not in scope of the
	function; pass it as an argument?*/
bool Mazes::is_wall(int v, int h, char direction) //current coordinates of the robot
{
	if (direction == 'n')
	{
		if (mymaze[v][h+1] == '#'
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else 
	if (direction == 'w')
	{
		if (mymaze[v][h-1] == '#'
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else
	{
		if (mymaze[v+1][h] == '#'
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else 
	{
		if (mymaze[v-1][h] == '#'
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else cout << "something went wrong" << endl;	
	
	return (true);
}




void t2::exit_search(Robots robot, vector<string> v_maze, int exit_v, int exit_h)
{
	cout << "Robot 2 in maze" << endl;
	step_counter = 0;
	
	/* coordinated of the robot, are directly accessible since they're
		stored in Robots (or t2)
		Declare them as v and h here because it's more practical
		than having to write robot.v every time
	*/
	int v = robot.v;
	int h = robot.h;
	
	while (!(v == this_maze.mazeexit[0]) && (h == this_maze.mazeexit[1])
	
	if (this_maze.is_wall(v, h, robot.direction, this_maze.v_maze))
	{
		turn_left(robot);
		exit_search(robot, this_maze);
	}
	else
	{
		step_forward(robot);
		step_counter++;
	}
	cout << "Steps taken: " << step_counter << endl;
	cout << "Current position (X,Y): " << robot.h << ", " << robot.v << endl;
}

