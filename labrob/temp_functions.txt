// Just a bunch of function ideas, not yet tested.


// would not need acces to Mazes
void Robots::turn_left(Robots robot)
{
	if (robot.direction == 'n')
	{
		robot.direction = 'w';
	}
	else 
	if (robot.direction == 'w')
	{
		robot.direction = 's';
	}
	else
	if (robot.direction == 's')
	{
		robot.direction = 'e';
	}
	else robot.direction = 'n';		
}


// would not need acces to Mazes
void Robots::step_forward(Robots robot)
{
	if (robot.direction == 'n')
	{
		v--;
	}
	else 
	if (robot.direction == 'w')
	{
		h--;
	}
	else
	if (robot.direction == 's')
	{
		v++;
	}
	else 
	if (robot.direction == 'e')
	{
		v--;
	}
	else cout << "something went wrong" << endl;		
}



void t2::exit_search(Robots robot, Mazes this_maze)
{
	step_counter = 0;
	
	/* coordinated of the robot, are directly accessible since they're
		stored in Robots (or t2) */
	int v = robot.v;
	int h = robot.h;
	
	while (!(v == this_maze.mazexit[0]) && h == this_maze.mazeexit[1])
	
	if (this_maze.is_wall(v, h, robot.direction))
	{
		turn_left(robot);
		exit_search(robot, v, h, this_maze);
	}
	else
	{
		step_forward(robot);
		step_counter++;
	}
}

/* There will be a problem because the mymaze in not in scope of the
	function; pass it as an argument?*/
bool Mazes::is_wall(int v, int h, char direction) //current coordinates of the robot
{
	if (direction == 'n')
	{
		if (mymaze[v][h+1] == '#'
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else 
	if (direction == 'w')
	{
		if (mymaze[v][h-1] == '#'
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else
	{
		if (mymaze[v+1][h] == '#'
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else 
	{
		if (mymaze[v-1][h] == '#'
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else cout << "something went wrong" << endl;	
	
	return (true);
}
