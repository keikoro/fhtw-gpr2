// Just a bunch of function ideas, not yet tested, because need to
// create instances of robots by going through robot_numbers
// vector first, and then communication between classes and so on.


void Robots::turn_left(Robots robot)
{
	if (robot.direction == 'n')
	{
		robot.direction = 'w';
	}
	else 
	if (robot.direction == 'w')
	{
		robot.direction = 's';
	}
	else
	if (robot.direction == 's')
	{
		robot.direction = 'e';
	}
	else robot.direction = 'n';		
}



void Robots::step_forward(Robots robot)
{
	if (robot.direction == 'n')
	{
		v--;
	}
	else 
	if (robot.direction == 'w')
	{
		h--;
	}
	else
	if (robot.direction == 's')
	{
		v++;
	}
	else 
	if (robot.direction == 'e')
	{
		v--;
	}
	else cout << "something went wrong" << endl;		
}



void t2::exit_search(Robots robot, int v, int h, Mazes this_maze)
{
	step_counter = 0;
	while (!(v == this_maze.mazexit[0]) && h == this_maze.mazeexit[1])
	
	if (this_maze.is_wall())
	{
		turn_left(robot);
		exit_search(robot, v, h, this_maze);
	}
	else
	{
		step_forward(robot);
		step_counter++;
	}
}


bool Mazes::is_wall(int v, int h) //current coordinates of the robot
{
	if (robot.direction == 'n')
	{
		if (v_maze[v][h+1] == '#'
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else 
	if (robot.direction == 'w')
	{
		if (v_maze[v][h-1] == '#'
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else
	{
		if (v_maze[v+1][h] == '#'
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else 
	{
		if (v_maze[v-1][h] == '#'
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else cout << "something went wrong" << endl;	
	
	return (true);
}


void Mazes::add_robot(Robots *a_robot, Mazes maze)
{
	robot_list.push_back (a_robot);
	a_robot->v = maze.entrance[0];
	a_robot->h = maze.entrance[1];
	a_robot->direction = maze.startposition;
}
